#!/BIGDATA1/app/R/4.1.0/bin/Rscript
### 根据不同品种之间LD一致性进行区间确定 ###

# 加载需要的程序包
cat("Loading required packages... \n")
suppressPackageStartupMessages(library("data.table"))
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("getopt"))
suppressPackageStartupMessages(library("Matrix"))

## 命令行参数
spec <- matrix(
  c("prefixs",   "I", 1, "character", "[Required] LD results file(s) generated by Plink",
    "map",       "m", 1, "character", "[Required] map/bim file of plink/NULL",
    "win",       "W", 1, "integer",   "[Optional] number of SNP in each region before merge/100",
    "bin_merge", "M", 1, "character", "[Optional] fix/ld/frq",
    "seg",       "E", 1, "double",    "[Optional] Criteria for interval consolidation [sd of set]",
    "var1",      "1", 1, "double",    "[Optional] genetical effect variance of trait 1",
    "var2",      "2", 1, "double",    "[Optional] genetical effect variance of trait 2",
    "out",       "O", 1, "character", "[Optional] output file name prefix/NULL",
    "dir",       "D", 1, "character", "[Optional] working directory/NULL",
    "help",      "h", 0, "logical",   "This is Help!"),
  byrow = TRUE, ncol = 5)
opt <- getopt(spec = spec)

# setwd('/BIGDATA2/cau_jfliu_2/liwn/mbGS/Real/AGE/multi')
# opt <- list()
# opt$prefixs="YY_ref DD_ref"
# opt$bin_merge="frq"
# opt$seg=0.1
# opt$win=100
# opt$map='/BIGDATA2/cau_jfliu_2/liwn/mbGS/Real/AGE/pA_pB_rmMiss.bim'
# opt$out='YY_DD_frq_0.1_merge_100.txt'

## 检查参数
if (!is.null(opt$help) || (is.null(opt$prefixs) && (is.null(opt$map) && opt$bin_merge == "fix"))) {
  cat(paste(getopt(spec = spec, usage = TRUE), "\n"))
  quit()
}

## 工作文件夹
if (!is.null(opt$dir)) setwd(opt$dir)

## 隐藏summarise的提示信息
options(dplyr.summarise.inform = FALSE)

## map文件
map <- read.table(opt$map)
names(map)[1:4] <- c("CHR", "SNP", "cM", "POS")

## SNP数目
snp_total <- nrow(map)

## 默认参数
if (is.null(opt$bin_merge)) opt$bin_merge <- "ld"
if (is.null(opt$win)) opt$win <- 100
# if (is.null(opt$slid)) opt$slid <- 25
if (is.null(opt$var1)) opt$var1 <- 1.0
if (is.null(opt$var2)) opt$var2 <- 1.0
if (is.null(opt$out)) opt$out <- paste(c(unlist(strsplit(opt$prefixs, " ")), "merge_bins.txt"), collapse = "_")

## 如果win=1，即输出一个区间，包含所有的标记
if (opt$win == 1) {
  bin_cor <- data.frame(chr = NA, bins = 1, nsnp = snp_total, pos_start = NA, pos_end = NA, data_cor = NA)
  write.table(bin_cor, opt$out, col.names = FALSE, row.names = FALSE)
  bin_cor <- data.frame(nsnp = snp_total)

  write.table(bin_cor, opt$out, col.names = FALSE, row.names = FALSE)
  cat("file with only one region has been outputed.\n")
  quit()
}

## 染色体编号
chrs <- unique(map$CHR)

## 输出固定snp数的区间
if (opt$bin_merge == "fix") {
  nsnp_bin <- NULL
  for (i in seq_along(chrs)) {
    nsnp_i <- sum(map$CHR == chrs[i])
    win_num <- floor(nsnp_i / opt$win)
    if (win_num < 1) win_num <- 1
    nsnp_bini <- rep(opt$win, win_num)
    nsnp_bini[win_num] <- nsnp_bini[win_num] + nsnp_i - sum(nsnp_bini)
    nsnp_bin <- c(nsnp_bin, nsnp_bini)
  }

  ## 检查SNP数目是否与map文件中相同
  if (snp_total != sum(nsnp_bin)) {
    cat("Error! The number of snps in bins file is inconsistent with the map file.\n")
    cat("bins=", sum(nsnp_bin), "≠", "map=", snp_total, "\n")
    quit(status = 1)
  }

  write.table(nsnp_bin, opt$out, col.names = FALSE, row.names = FALSE)
  cat("Number of fixed bins: ", length(nsnp_bin), "\n")
  cat("File contain fixed number of snps in bins has been output to: ", opt$out, "\n")
  quit()
}

## 文件名
prefixs <- unlist(strsplit(opt$prefixs, " "))
if (opt$bin_merge == "ld") {
  files <- paste0(prefixs, ".ld")
} else if (opt$bin_merge == "frq") {
  files <- paste0(prefixs, ".frq")
} else if (opt$bin_merge == "gwas") {
  files <- paste0(prefixs, ".assoc.txt")
} else {
  cat("bin_merge can only be frq/ld.\n")
  quit()
}

# ## 群体个数
# nP <- length(files)

## 检查文件是否存在
if (!file.exists(files[1])) {
  cat(files[1], "not found!\n")
  quit()
} else if (!file.exists(files[2])) {
  cat(files[2], "not found!\n")
  quit()
}

## 读取plink的ld结果
cat("Reading files...\n")
data1 <- fread(files[1])
data2 <- fread(files[2])
cat("results loaded.\n")

## 文件类型（ld/frq文件）
if (opt$bin_merge == "ld") {
  names(data1)[1] <- names(data2)[1] <- "CHR"
  data12 <- inner_join(data1, data2, by = c("CHR", "BP_A", "BP_B"), suffix = c("_1", "_2"))

  ## 标记对之间的距离
  data12$dist <- abs(data12$BP_A - data12$BP_B) / 1000
  # data12 <- data12[!data12$dist > opt$max, ]

  ## 剔除完全连锁的标记对
  data12 <- subset(data12, !(R2_1 == 1 & R2_2 == 1))
} else if (opt$bin_merge == "frq") {
  ## 计算相关的列统一成"R2"
  names(data1)[5] <- names(data2)[5] <- "R2"

  data12 <- inner_join(data1, data2, by = c("CHR", "SNP"), suffix = c("_1", "_2"))

  trans <- data12$A1_1 == data12$A2_2 & data12$A2_1 == data12$A1_2
  matchs <- data12$A1_1 == data12$A1_2 & data12$A2_1 == data12$A2_2
  if (sum(trans, matchs) != nrow(data12)) {
    cat("There are other types of conditions, please check (line91)\n")
    quit(status = 1)
  }

  ## 更改碱基和基因频率
  data12$A1_2[trans] <- data12$A1_1[trans]
  data12$A2_2[trans] <- data12$A2_1[trans]
  data12$R2_2[trans] <- 1 - data12$R2_2[trans]

  ## 品种间基因频率相关
} else if (opt$bin_merge == "frq") {
  ## 计算相关的列统一成"R2"
  col_name <- c("CHR", "SNP", "POS", "R2")
  cols <- c(1:3, 12)
  names(data1)[cols] <- names(data2)[cols] <- col_name
  data12 <- inner_join(data1, data2, by = c("CHR", "SNP"), suffix = c("_1", "_2"))
} else {
  cat("bin_merge can only be ld/frq!\n")
  quit(status = 1)
}

## 删除中间文件
rm(data1, data2)

## 报告整体相关去情况
cors <- cor(data12$R2_1, data12$R2_2)
cat("The overall correlation is:", cors, "\n")

## 合并临近区间并重新计算相关的函数
bins_merge <- function(stat_df, stat_bin, data_df, data_bin, seg = NULL) {
  # stat_df=bin_cor; stat_bin='bin_A'; data_df=data12_stat; data_bin='bin_A'; seg=opt$seg

  ## 如果seg为NULL，则设为窗口相关的1倍标准差
  if (is.null(seg)) seg <- sd(stat_df$cor)

  i <- 1
  stat_df[["bin_temp"]] <- NA
  stat_df[["nsnp_new"]] <- NA
  while (i <= nrow(stat_df)) {
    s <- i
    e <- i
    hit <- FALSE
    while (!hit && i <= nrow(stat_df)) {
      if (i < nrow(stat_df)) {
        diff_cor <- abs(stat_df$cor[i] - stat_df$cor[i + 1]) >= seg
        diff_chr <- stat_df$CHR[i] != stat_df$CHR[i + 1]
      } else {
        diff_cor <- TRUE
        diff_chr <- TRUE
      }

      if (diff_cor || diff_chr) {
        e <- i
        hit <- TRUE
      }
      i <- i + 1
    }
    stat_df$bin_temp[s:e] <- stat_df[[stat_bin]][s]
    stat_df$nsnp_new[s:e] <- sum(stat_df$nsnp[s:e])
  }

  ## 重新计算cor
  names(stat_df)[which(names(stat_df) == stat_bin)] <- data_bin
  bin_new <- stat_df[, c(data_bin, "bin_temp", "nsnp_new")]
  data_df <- left_join(data_df, bin_new, by = data_bin)
  stat_df <- dplyr::group_by(data_df, CHR, bin_temp) %>%
    dplyr::summarise(nsnp = mean(nsnp_new), start = min(BP_A, BP_B), end = max(BP_A, BP_B), cor = cor(R2_1, R2_2))

  ## 标准差为0的设为相关设为临近标记相关
  sd0 <- which(is.na(stat_df$cor))
  stat_df$cor[sd0] <- stat_df$cor[sd0 - 1]

  names(stat_df)[2] <- data_bin

  ## 将区间标记改为连续整数
  stat_df[[data_bin]] <- as.numeric(as.factor(stat_df[[data_bin]]))

  return(stat_df)
}

## 初步划分区间
cat("Preliminary division based on ", opt$win, " SNPs in each bins...\n")
map$bin <- NA
map$nsnp <- NA
bin_start <- 1
for (i in seq_along(chrs)) {
  ## 第i染色体的SNP数
  nsnp_i <- sum(map$CHR == chrs[i])
  ## 以opt$win为一组可以划分的区间数
  win_num <- floor(nsnp_i / opt$win)
  ## 若该染色体上的标记数少于win，则win_num为1
  if (win_num < 1) win_num <- 1
  ## 每个区间的SNP数，最后一个区间可以超出opt$win
  nsnp_bin <- rep(opt$win, win_num)
  nsnp_bin[win_num] <- nsnp_bin[win_num] + nsnp_i - sum(nsnp_bin)
  ## 染色体i每个SNP的区间标签
  group <- rep(bin_start:(win_num + bin_start - 1), times = nsnp_bin)
  map$bin[map$CHR == chrs[i]] <- group[1:nsnp_i]
  ## 每个区间的SNP数
  nsnp_bin_map <- rep(nsnp_bin, times = nsnp_bin)
  map$nsnp[map$CHR == chrs[i]] <- nsnp_bin_map
  ## 区间数记录
  bin_start <- bin_start + win_num
}
cat("Number of bins before merging: ", max(map$bin), "\n")

## 为ld结果文件中标记对匹配bin区间
bins <- map[, c("CHR", "SNP", "POS", "bin", "nsnp")]
names(bins)[c(3, 4)] <- c("BP_A", "bin_A")
if (opt$bin_merge == "ld") {
  data12_bin <- inner_join(data12, bins, by = c("CHR", "BP_A"))
  bins <- bins[, -ncol(bins)]
  names(bins) <- c("CHR", "SNP", "BP_B", "bin_B")
  data12_bin <- inner_join(data12_bin, bins, by = c("CHR", "BP_B"))
  data12_stat <- subset(data12_bin, bin_A == bin_B)
} else {
  data12_stat <- inner_join(data12, bins, by = c("CHR", "SNP"), suffix = c("_1", "_2"))
  data12_stat$BP_B <- data12_stat$BP_A
}

## 统计区间内的LD一致性
bin_cor <- dplyr::group_by(data12_stat, CHR, bin_A) %>%
  dplyr::summarise(nsnp = mean(nsnp), start = min(BP_A, BP_B), end = max(BP_A, BP_B), cor = cor(R2_1, R2_2))

## 标准差为0的设为相关设为临近标记相关
if (any((is.na(bin_cor$cor)))) {
  sd0 <- which(is.na(bin_cor$cor))
  for (i in sd0) {
    if (i > max(bin_cor$bin_A) %/% 2) {
      end <- max(bin_cor$bin_A)
    } else {
      end <- 1
    }

    for (j in i:end) {
      if (!is.na(bin_cor$cor[j])) {
        bin_cor$cor[sd0] <- bin_cor$cor[j]
        break
      }
    }
  }
}

## 根据一定阈值合并邻近窗口
if (is.null(opt$seg)) opt$seg <- sd(bin_cor$cor)
cat("Merging adjacent windows base on threshold: ", opt$seg, "...\n")
bin_cor_m <- bins_merge(bin_cor, "bin_A", data12_stat, "bin_A", opt$seg)

## 检查是否所有的染色体都在binCor中
miss_chrs <- unique(map$CHR[!map$CHR %in% bin_cor_m$CHR])
if (length(miss_chrs) > 0) {
  ## 增加缺失染色体的标记
  for (i in miss_chrs) {
    add <- data.frame(
      CHR = i, bin_A = max(bin_cor_m$bin_A) + 1, nsnp = sum(map$CHR == i),
      start = min(map$POS[map$CHR == i]), end = max(map$POS[map$CHR == i]), cor = 0
    )
    bin_cor_m <- rbind(bin_cor_m, add)
  }
}

## 检查SNP数目是否与map文件中相同
if (snp_total != sum(bin_cor_m$nsnp)) {
  cat("Error! The number of snps in bins file is inconsistent with the map file.\n")
  cat("bins=", sum(bin_cor_m$nsnp), "≠", "map=", snp_total, "\n")
  quit(status = 1)
}

# ## 计算每个区间的遗传(协)方差
# bin_cor_m$var1 <- opt$var1 * bin_cor_m$nsnp / snp_total
# bin_cor_m$cov1 <- bin_cor_m$cov2 <- 0
# bin_cor_m$var2 <- opt$var2 * bin_cor_m$nsnp / snp_total
# bin_cor_m$cov1 <- bin_cor_m$cov2 <- bin_cor_m$cor * sqrt(bin_cor_m$var1) * sqrt(bin_cor_m$var2)

# ## 保证(协)方差阵的正定性
# bin_cor_m <- as.data.frame(bin_cor_m)
# for (i in 1:nrow(bin_cor_m)) {
#   vari <- Matrix(unlist(bin_cor_m[i, c("var1", "cov1", "cov2", "var2")]), 2, 2)
#   vari_PD  <- nearPD(vari, keepDiag = TRUE) # default
#   if (!vari_PD$converged) {
#     cat('warning! The positive definiteness of bin ', i, ' matrix cannot be guaranteed.\n')
#   } else if (vari_PD$iterations > 1) {
#     cat('The covariance matrix of bin ', i, ' is set to: \n', vari_PD$mat, '\n')
#     bin_cor_m[i, c("var1", "cov1", "cov2", "var2")] <- as.vector(vari_PD$mat)
#   }
# }

write.table(bin_cor_m, opt$out, col.names = FALSE, row.names = FALSE)
cat("Number of bins after merging: ", nrow(bin_cor_m), "\n")
cat("File contain number of snps in bins has been output to: ", opt$out, "\n")


## debug
# setwd('/BIGDATA2/cau_jfliu_2/liwn/mbGS/QMSim/Frq/frq_0.2/identical/cor0.25/multi')
opt <- list()
opt$prefixs <- "breedA_ref breedB_ref"
opt$bin_merge <- "frq"
opt$seg <- 0.1
opt$win <- 100
opt$map <- "/BIGDATA2/cau_jfliu_2/liwn/mbGS/QMSim/Frq/frq_0.2/identical/cor0.25/pA_pB.bim"
opt$out <- "frq_0.1_100_full.txt"

# setwd('/BIGDATA2/cau_jfliu_2/liwn/mbGS/Real/GWAS')
opt <- list()
opt$prefixs <- "YY_debv_ADFI DD_debv_ADFI"
opt$bin_merge <- "gwas"
opt$seg <- 0.1
opt$win <- 100
opt$map <- "/BIGDATA2/cau_jfliu_2/liwn/mbGS/Real/rmodel/AGE/pA_pB.bim"
opt$out <- "gwas_0.1_100_full.txt"
